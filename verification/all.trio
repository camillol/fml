class Collector;
	inherits WaterContainer [redefine delta_heat_definition];
	
	visible
		sun_heat;
	
	variables
		sun_heat: real;
	
	axioms
		delta_heat_definition:
			delta_heat = sun_heat;

end Collector.
class Controller;

	visible
		pump_control, pump_state, maintenance, temp_tank, temp_collector;

	temporal domain natural;

	TD items
		predicates
			pump_control({start, stop});
			pump_state({on,off});
			maintenance;
		variables
			temp_tank, temp_collector, delta_temp: real;

	TI items
		consts
			delta_low_thresh, delta_high_thresh: real;
	
	axioms

		sane_consts:
			delta_high_thresh > delta_low_thresh > 0
		
		define_delta:
			delta_temp = temp_collector - temp_tank
		
		Start:	-- turn on pump when delta is high enough and the system isn't in maintenance mode
			UpToNow(pump_state(off)) ^ delta_temp > delta_high_thresh ^ ¬maintenance <->
				pump_control(start)
		
		Stop:	-- turn off pump when delta is low enough or the system is in maintenance mode
			UpToNow(pump_state(on)) ^ ( delta_temp < delta_low_thresh v maintenance ) <->
				pump_control(stop)

end Controller.
class SolarHeatingSystem;

	visible
		sun_heat, tap_control, start_maintenance, cold_supply_temperature;

	temporal domain natural;

	TD items
		predicates
		variables

	TI items
		consts
			total_volume: real;
	
	modules
		controller: Controller;
		collector: Collector;
		tank: Tank;
		pump: Pump;
		tap: Tap;		-- user drawing hot water
		tank_sensor, collector_sensor: Sensor;
	
	connections {
		(controller.pump_control, pump.control),
		(controller.pump_state, pump.state),
		(controller.temp_tank, tank_sensor.temp_reading),
		(controller.temp_collector, collector_sensor.temp_reading),
		
		(collector_sensor.thermometer, collector.out_temperature),
		(tank_sensor.thermometer, tank.out_temperature),
		
		(pump.in_volume, tank.out_volume),
		(pump.in_temperature, tank.out_temperature),

		(pump.out_volume, collector.in_volume),
		(pump.out_temperature, collector.in_temperature),
		
		(tank.in_volume, collector.out_volume),
		(tank.in_temperature, collector.out_temperature),
		
		(tap.in_volume, tank.tap_out_volume),
		(tap.in_temperature, tank.tap_out_temperature),

		(tap.out_volume, tank.tap_in_volume),
		(tap.out_temperature, tank.tap_in_temperature)

		(maintainer.working, controller.maintenance),
		
		-- external interface
		(sun_heat, collector.sun_heat),
		(tap_control, tap.control),
		(start_maintenance, maintainer.startwork),
		(cold_supply_temperature, tap.cold_supply_temperature),
	}
	
	axioms
		vars
			t: real;

		NoLeaks:
			tank.volume + collector.volume = total_volume;
		
		ColdSupplyLiquid:
			0 < cold_supply_temperature < 100;

end SolarHeatingSystem.
class Maintainer;
	
	visible:
		startwork, working;

	temporal domain natural;

	TD items
		predicates
			startwork; --this is true when the maintainer starts working on the collector			
			working; -- this is true while the maintainer is working on the collector
	TI items
		consts
			min_maintenance_interval, max_maintenance_interval, worktime: real;
			
	axioms
		vars
			t: real;
			
		enforce_maximum_interval:
			Lasted_ee(¬working, max_maintenance_interval) -> startwork;
		
		enforce_minimum_interval:
			startwork -> Lasted_ee(¬startwork, min_maintenance_interval);
			
		initially_not_working:
			AlwP(¬startwork) -> ¬working;
			
		work_period:
			WithinP_ei(startwork, worktime) <-> working;

		sane_times:
			worktime < min_maintenance_interval;

end Maintainer.
class Pump;
	
	visible:
		control, state, in_volume, in_temperature, out_volume, out_temperature;
	temporal domain natural;

	TD items
		predicates
			control({start, stop});
			state({on,off});
		variables
			in_volume, in_temperature,
			out_volume, out_temperature: real;
	TI items
		consts
			pump_volume: real;
	
	axioms
	
		StartOff:
			AlwP(¬control(start)) -> state(off)

		SameAmount:
			in_volume = out_volume
			
		SameTemp:
			in_temperature = out_temperature
		
		WhenOff:
			state(off) -> in_volume = 0
		
		WhenOn:
			state(on) -> in_volume = pump_volume
		
		Start:
			UpToNow(state(off)) ^ control(start) -> Until_ei(control(stop), state(on))

		Stop:
			UpToNow(state(on)) ^ control(stop) -> Until_ei(control(start), state(off))

		StateUnique:
			(state(off) ^ ¬state(on)) v (state(on) ^ ¬state(off))

end Pump.
class Sensor

	visible
		temp_reading, thermometer;

	temporal domain natural;

	TD items
		variables
			temp_reading, thermometer: real;
			
		predicates
			update;
			
	TI items
		consts
			polling_interval: natural;
			
	axioms
	
		periodicity:
			update -> NextTime(update, polling_interval) ^
				∃ thermometer_now (
					thermometer_now = thermometer ^
					Lasts_ie(temp_reading = thermometer_now, polling_interval)
				)
		
		start_update:
			AlwP(¬update) -> update

end Sensor.
class Tank;
	inherits WaterContainer [redefine
		delta_volume_definition,
		total_out_volume_definition,
		total_in_volume_temperature_product_definition
	];
	
	variables
		tap_in_volume, tap_in_temperature,
		tap_out_volume, tap_out_temperature,
		total_out_volume,
		total_in_volume_temperature_product,
		total_out_volume_temperature_product: real;
	
	axioms
		no_state_changes_tap:
			0 < tap_in_temperature < 100 ^
			0 < tap_out_temperature < 100

		delta_volume_definition:
			delta_volume = in_volume - out_volume + tap_in_volume - tap_out_volume

		temperature_out_tap:
			tap_out_temperature = temperature
		
		total_out_volume_definition:
			total_out_volume = out_volume + tap_out_volume
		
		total_in_volume_temperature_product_definition:
			total_in_volume_temperature_product = in_volume * in_temperature +
							tap_in_volume * tap_in_temperature

end Tank.
class Tap;
	
	visible
		cold_supply_temperature;
	
	inherits Pump [redefine SameTemp]
	
	TD items
		variables
			cold_supply_temperature: real;
	
	axioms
	
		SameTemp:
			out_temperature = cold_supply_temperature

end Tap.
class Water_Container

	visible
		in_volume, in_temperature,
		out_volume, out_temperature,
		volume; -- only exposing volume for the noleaks axiom on the system
	temporal domain natural;
	
	TD items
		variables
			temperature, volume,
			in_volume, in_temperature,
			out_volume, out_temperature,
			delta_volume,
			delta_heat: real;
			
	TI items
		consts
			max_volume,
			specific_heat, density : real;	-- water properties
			
	axioms
		vars
			volume_now, temperature_now,
			in_volume_now, in_temperature_now,
			out_volume_now, out_temperature_now,
			delta_volume_now: real;
	
		no_state_changes:
			0 < temperature < 100 ^
			0 < in_temperature < 100 ^
			0 < out_temperature < 100
			
		volume_within_bounds: 
			0 < volume <= max_volume;
			
		volume_remains_constant:
			∃volume_now ( volume = volume_now ^ Futr(volume = volume_now, 1) )
		
		delta_volume_definition:
			delta_volume = in_volume - out_volume
		
		volume_change:
			∃delta_volume_now, volume_now (
				volume = volume_now ^
				delta_volume = delta_volume_now ^
				Futr(volume = volume_now + delta_volume_now, 1)
			)
		
		temperature_out:
			out_temperature = temperature
		
		delta_heat_definition:	-- by default we don't have any other energy input/output
			delta_heat = 0

		total_out_volume_definition:
			total_out_volume = out_volume
		
		total_in_volume_temperature_product_definition:
			total_in_volume_temperature_product = in_volume * in_temperature

		total_out_volume_temperature_product_definition:
			total_out_volume_temperature_product = total_out_volume * temperature

		temperature_change:
			∃volume_now, temperature_now, total_out_volume_temperature_product_now, total_in_volume_temperature_product_now (
				volume = volume_now ^
				temperature = temperature_now ^
				total_out_volume_temperature_product = total_out_volume_temperature_product_now ^
				total_in_volume_temperature_product = total_in_volume_temperature_product_now ^
				Futr(temperature = (
						-- weigthed average of temperatures of volumes which compose the next
						-- water volume
						(
							volume_now * temperature_now
							- total_out_volume_temperature_product_now
							+ total_in_volume_temperature_product_now
						) / volume								-- yes, this is the future volume
						
						-- temperature change from external heat exchange (not by water exchange)
						+ delta_heat / (specific_heat * volume * density)
					, 1)
			)
	
end Water_Container
