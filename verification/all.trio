variables
	pump_start:[0..1], pump_stop:[0..1], pump_on:[0..1], pump_off:[0..1],

	temp_tank:[-2..8], temp_collector:[-2..8], delta_temp:[-10..10],
	pump_in_volume:[0..1], pump_in_temperature:[-2..8], pump_out_volume:[0..1], out_temperature:[-2..8]

constants
	DELTA_LOW_THRESH=2, DELTA_HIGH_THRESH=4, PUMP_VOLUME=1

axioms
	controller_sane_consts:
		DELTA_HIGH_THRESH > DELTA_LOW_THRESH > 0
	
	controller_define_delta:
		delta_temp = temp_collector - temp_tank
	
	controller_start:	-- turn on pump when delta is high enough and the system isn't in maintenance mode
		UpToNow(pump_off) & delta_temp > DELTA_HIGH_THRESH & !maintenance <-> pump_start
	
	controller_stop:	-- turn off pump when delta is low enough or the system is in maintenance mode
		UpToNow(pump_on) & ( delta_temp < DELTA_LOW_THRESH | maintenance ) <-> pump_stop

	pump_start_off:
		AlwP(!control_start) -> state_off

	pump_same_amount:
		pump_in_volume = pump_out_volume
			
	pump_same_temp:
		pump_in_temperature = pump_out_temperature
		
	pump_when_off:
		pump_off -> pump_in_volume = 0
		
	pump_when_on:
		pump_on -> pump_in_volume = PUMP_VOLUME
		
	pump_start:
		UpToNow(pump_off) & pump_start -> Until_ei(pump_stop, pump_on)

	pump_stop:
		UpToNow(pump_on) & pump_stop -> Until_ei(pump_start, pump_off)

	pump_state_unique:
		(pump_off & !pump_on) | (pump_on ^ !pump_off)


-------------------------------------------------

class Collector;
	inherits WaterContainer [redefine delta_heat_definition];
	
	visible
		sun_heat;
	
	variables
		sun_heat: real;
	
	axioms
		delta_heat_definition:
			delta_heat = sun_heat;

end Collector.

class SolarHeatingSystem;

	visible
		sun_heat, tap_control, start_maintenance, cold_supply_temperature;

	temporal domain natural;

	TD items
		predicates
		variables

	TI items
		consts
			total_volume: real;
	
	modules
		controller: Controller;
		collector: Collector;
		tank: Tank;
		pump: Pump;
		tap: Tap;		-- user drawing hot water
		tank_sensor, collector_sensor: Sensor;
	
	connections {
		(controller.pump_control, pump.control),
		(controller.pump_state, pump.state),
		(controller.temp_tank, tank_sensor.temp_reading),
		(controller.temp_collector, collector_sensor.temp_reading),
		
		(collector_sensor.thermometer, collector.out_temperature),
		(tank_sensor.thermometer, tank.out_temperature),
		
		(pump.in_volume, tank.out_volume),
		(pump.in_temperature, tank.out_temperature),

		(pump.out_volume, collector.in_volume),
		(pump.out_temperature, collector.in_temperature),
		
		(tank.in_volume, collector.out_volume),
		(tank.in_temperature, collector.out_temperature),
		
		(tap.in_volume, tank.tap_out_volume),
		(tap.in_temperature, tank.tap_out_temperature),

		(tap.out_volume, tank.tap_in_volume),
		(tap.out_temperature, tank.tap_in_temperature)

		(maintainer.working, controller.maintenance),
		
		-- external interface
		(sun_heat, collector.sun_heat),
		(tap_control, tap.control),
		(start_maintenance, maintainer.startwork),
		(cold_supply_temperature, tap.cold_supply_temperature),
	}
	
	axioms
		vars
			t: real;

		NoLeaks:
			tank.volume + collector.volume = total_volume;
		
		ColdSupplyLiquid:
			0 < cold_supply_temperature < 100;

end SolarHeatingSystem.



class Sensor

	visible
		temp_reading, thermometer;

	temporal domain natural;

	TD items
		variables
			temp_reading, thermometer: real;
			
		predicates
			update;
			
	TI items
		consts
			polling_interval: natural;
			
	axioms
	
		periodicity:
			update -> NextTime(update, polling_interval) ^
				∃ thermometer_now (
					thermometer_now = thermometer ^
					Lasts_ie(temp_reading = thermometer_now, polling_interval)
				)
		
		start_update:
			AlwP(¬update) -> update

end Sensor.
class Tank;
	inherits WaterContainer [redefine
		delta_volume_definition,
		total_out_volume_definition,
		total_in_volume_temperature_product_definition
	];
	
	variables
		tap_in_volume, tap_in_temperature,
		tap_out_volume, tap_out_temperature,
		total_out_volume,
		total_in_volume_temperature_product,
		total_out_volume_temperature_product: real;
	
	axioms
		no_state_changes_tap:
			0 < tap_in_temperature < 100 ^
			0 < tap_out_temperature < 100

		delta_volume_definition:
			delta_volume = in_volume - out_volume + tap_in_volume - tap_out_volume

		temperature_out_tap:
			tap_out_temperature = temperature
		
		total_out_volume_definition:
			total_out_volume = out_volume + tap_out_volume
		
		total_in_volume_temperature_product_definition:
			total_in_volume_temperature_product = in_volume * in_temperature +
							tap_in_volume * tap_in_temperature

end Tank.

class Tap;
	
	visible
		cold_supply_temperature;
	
	inherits Pump [redefine SameTemp]
	
	TD items
		variables
			cold_supply_temperature: real;
	
	axioms
	
		SameTemp:
			out_temperature = cold_supply_temperature

end Tap.
class Water_Container

	visible
		in_volume, in_temperature,
		out_volume, out_temperature,
		volume; -- only exposing volume for the noleaks axiom on the system
	temporal domain natural;
	
	TD items
		variables
			temperature, volume,
			in_volume, in_temperature,
			out_volume, out_temperature,
			delta_volume,
			delta_heat: real;
			
	TI items
		consts
			max_volume,
			specific_heat, density : real;	-- water properties
			
	axioms
		vars
			volume_now, temperature_now,
			in_volume_now, in_temperature_now,
			out_volume_now, out_temperature_now,
			delta_volume_now: real;
	
		no_state_changes:
			0 < temperature < 100 ^
			0 < in_temperature < 100 ^
			0 < out_temperature < 100
			
		volume_within_bounds: 
			0 < volume <= max_volume;
			
		volume_remains_constant:
			∃volume_now ( volume = volume_now ^ Futr(volume = volume_now, 1) )
		
		delta_volume_definition:
			delta_volume = in_volume - out_volume
		
		volume_change:
			∃delta_volume_now, volume_now (
				volume = volume_now ^
				delta_volume = delta_volume_now ^
				Futr(volume = volume_now + delta_volume_now, 1)
			)
		
		temperature_out:
			out_temperature = temperature
		
		delta_heat_definition:	-- by default we don't have any other energy input/output
			delta_heat = 0

		total_out_volume_definition:
			total_out_volume = out_volume
		
		total_in_volume_temperature_product_definition:
			total_in_volume_temperature_product = in_volume * in_temperature

		total_out_volume_temperature_product_definition:
			total_out_volume_temperature_product = total_out_volume * temperature

		temperature_change:
			∃volume_now, temperature_now, total_out_volume_temperature_product_now, total_in_volume_temperature_product_now (
				volume = volume_now ^
				temperature = temperature_now ^
				total_out_volume_temperature_product = total_out_volume_temperature_product_now ^
				total_in_volume_temperature_product = total_in_volume_temperature_product_now ^
				Futr(temperature = (
						-- weigthed average of temperatures of volumes which compose the next
						-- water volume
						(
							volume_now * temperature_now
							- total_out_volume_temperature_product_now
							+ total_in_volume_temperature_product_now
						) / volume								-- yes, this is the future volume
						
						-- temperature change from external heat exchange (not by water exchange)
						+ delta_heat / (specific_heat * volume * density)
					, 1)
			)
	
end Water_Container
